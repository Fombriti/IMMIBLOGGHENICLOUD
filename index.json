[{"body":"Intro Recentemente mi è stato richiesto di creare alcuni Blueprint e mostrare il prezzo della risorsa al momento della richiesta attraverso il service broker. Questo senza avere la possibilità di utilizzare le pricing cards di VMware Aria Automation.\nLa necessità era quella di mostrare template con queste caratteristiche:\nTemplate Azure OS: Windows And Linux 3 Flavours: Small, Medium and Large Managed or Unamanged Machine (SLA) In case the vm is managed you have Monitoring SLA - STD or H24 Template GCP OS: Windows And Linux 3 Flavours: Small, Medium And Large Managed or Unamanged Machine (SLA) In case the vm is managed you have Monitoring SLA - STD or H24 Template vCenter Windows OS: Windows 2019 or 2022 3 Flavours: Small, Medium And Large Managed or Unamanged Machine In case the vm is managed you have Monitoring SLA - STD or H24 Il prezzo varia a seconda del Flavour, del sistema operativo, dal fatto che sia Managed o Unamanged e dal tipo di SLA in caso la vm sia managed.\nPer avere una gestione degli aggiornamenti dei prezzi futuri più elastica possibile la mia soluzione è stata quella di andare a leggere i prezzi da un file CSV utilizzando Powershell.\nPreparazione delle risorse Blueprints In vediamo i 3 Blueprint che ho preparato:\nvCenter Windows Blueprint Questo Blueprint prevede il deploy di una vm, in questo caso Windows e viene specificato in quale vCenter e Storage allocarla.\nCon Managed si intende una vm di produzione deve essere monitorata, backuppata ecc.. Lo SLA dovrebbe essere \u0026quot;Yes\u0026quot; solo nel caso la vm sia Managed.\nGli input e quindi le possibilità di personalizzazione sono:\nNome Image Flavour SLA Managed Network 1formatVersion: 1 2inputs: 3 Name: 4 type: string 5 title: Name 6 Image: 7 type: string 8 title: Image 9 oneOf: 10 - title: WIN-SRV-2019 11 const: WIN-2019-TEMPLATE 12 - title: WIN-SRV-2022 13 const: WIN-2022-TEMPLATE 14 default: WIN-2019-TEMPLATE 15 Flavour: 16 type: string 17 title: Flavour 18 oneOf: 19 - title: SMALL 20 const: SMALL 21 - title: MEDIUM 22 const: MEDIUM 23 - title: LARGE 24 const: LARGE 25 Managed: 26 type: string 27 titile: Manged 28 oneOf: 29 - title: \u0026#39;Yes\u0026#39; 30 const: \u0026#39;YES\u0026#39; 31 - title: \u0026#39;No\u0026#39; 32 const: \u0026#39;NO\u0026#39; 33 sla: 34 type: string 35 title: SLA 36 oneOf: 37 - title: H24 38 const: H24 39 - title: STD 40 const: STD 41 Network: 42 type: string 43 title: Network 44 oneOf: 45 - title: YOUR_NETWORK_NAME 46 const: network:YOUR_NETWORK_TAG 47resources: 48 Cloud_vSphere_Machine_1: 49 type: Cloud.vSphere.Machine 50 properties: 51 name: ${input.Name} 52 image: ${input.Image} 53 flavor: ${input.Flavour} 54 Managed: ${input.Managed} 55 sla: ${input.sla} 56 storage: 57 constraints: 58 - tag: Storage:YOUR_STORAGE_TAG 59 networks: 60 - network: ${resource.Cloud_vSphere_Network_1.id} 61 constraints: 62 - tag: Cluster:YOUR_CLUSTER_TAG 63 Cloud_vSphere_Network_1: 64 type: Cloud.vSphere.Network 65 properties: 66 networkType: existing 67 constraints: 68 - tag: ${input.Network} GCP Blueprint Il Blueprint GCP disponde di immagini windows e linux, in questo caso essendo configurato un solo Cloud Account non c'è bisogno di specificare cose come il cluster ma basterà aggiungere il tag associato alla Cloud Zone alla vm.\nGli input sono:\nNome Image Flavour SLA Managed 1 2formatVersion: 1 3inputs: 4 Name: 5 type: string 6 title: Name 7 Image: 8 type: string 9 title: System OS 10 description: Choose OS 11 oneOf: 12 - title: Windows Server 2022 13 const: GCP-IMG_Win202022 14 - title: Windows Server 2019 15 const: GCP-IMG_Win2019 16 - title: UBUNTU-2210 17 const: GCP-UBUNTU-2210 18 default: GCP-IMG_Win2019 19 Flavour: 20 type: string 21 title: Flavour 22 oneOf: 23 - title: SMALL 24 const: SMALL-GCP-n2-standard-2 25 - title: MEDIUM 26 const: MEDIUM-GCP-n2-standard-4 27 - title: LARGE 28 const: LARGE-GCP-n2-standard-8 29 Managed: 30 type: string 31 titile: Manged 32 oneOf: 33 - title: \u0026#39;Yes\u0026#39; 34 const: \u0026#39;YES\u0026#39; 35 - title: \u0026#39;No\u0026#39; 36 const: \u0026#39;NO\u0026#39; 37 sla: 38 type: string 39 title: SLA 40 oneOf: 41 - title: H24 42 const: H24 43 - title: STD 44 const: STD 45resources: 46 Cloud_GCP_Machine_1: 47 type: Cloud.GCP.Machine 48 properties: 49 name: ${input.Name} 50 image: ${input.Image} 51 flavor: ${input.Flavour} 52 Managed: ${input.Managed} 53 sla: ${input.sla} 54 networks: 55 - assignPublicIpAddress: false 56 constraints: 57 - tag: platform:gcp #match only one gcp cloud zone and associated network Azure Blueprint Anche in questo caso ho mappato immagini Windows e Linux, il resto del template è molto simile ai precedenti.\nGli input sono come per GCP:\nNome Image Flavour SLA Managed 1formatVersion: 1 2inputs: 3 Name: 4 type: string 5 title: Name 6 Image: 7 type: string 8 title: System OS 9 description: Choose OS 10 oneOf: 11 - title: Windows Server 2019 12 const: Azure-WindowsServer:2019-Datacenter:lates 13 - title: UBUNTU-2204 14 const: AZURE-UBUNTU-2204 15 default: Azure-WindowsServer:2019-Datacenter:lates 16 Flavour: 17 type: string 18 title: Flavour 19 oneOf: 20 - title: SMALL 21 const: Azure-Standard_B2as_v2 22 - title: MEDIUM 23 const: Azure-Standard_B4als_v2 24 - title: LARGE 25 const: Azure-Standard_B8als_v2 26 Managed: 27 type: string 28 titile: Manged 29 oneOf: 30 - title: \u0026#39;Yes\u0026#39; 31 const: \u0026#39;YES\u0026#39; 32 - title: \u0026#39;No\u0026#39; 33 const: \u0026#39;NO\u0026#39; 34 sla: 35 type: string 36 title: SLA 37 oneOf: 38 - title: H24 39 const: H24 40 - title: STD 41 const: STD 42resources: 43 Cloud_Network_1: 44 type: Cloud.Network 45 properties: 46 networkType: existing 47 constraints: 48 - tag: Network:YOUR_AZURE_NETWORK_TAG 49 Cloud_Azure_Machine_1: 50 type: Cloud.Azure.Machine 51 properties: 52 image: ${input.Image} 53 flavor: ${input.Flavour} 54 Managed: ${input.Managed} 55 sla: ${input.sla} 56 constraints: 57 - tag: YOUR_AZURE_ZONE_TAG 58 networks: 59 - network: ${resource.Cloud_Network_1.id} 60 - assignPublicIpAddress: false CSV file vRo Action Service Broker Using vRo Action in Service Broker Notes ","link":"https://www.immiblogghenicloud.cloud/aria-automation-prices-without-price-cards/","section":"","tags":["POWERSHELL","VMWARE","VRA","VRO"],"title":"Aria Automation - Prices without price cards"},{"body":"","link":"https://www.immiblogghenicloud.cloud/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://www.immiblogghenicloud.cloud/","section":"","tags":null,"title":"IMMIBLOGGHENICLOUD"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/powershell/","section":"tags","tags":null,"title":"POWERSHELL"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://www.immiblogghenicloud.cloud/categories/vmware/","section":"categories","tags":null,"title":"vmware"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/vmware/","section":"tags","tags":null,"title":"VMWARE"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/vra/","section":"tags","tags":null,"title":"VRA"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/vro/","section":"tags","tags":null,"title":"VRO"},{"body":"","link":"https://www.immiblogghenicloud.cloud/categories/microsoft/","section":"categories","tags":null,"title":"Microsoft"},{"body":"","link":"https://www.immiblogghenicloud.cloud/posts/","section":"posts","tags":null,"title":"Posts"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/sccm/","section":"tags","tags":null,"title":"SCCM"},{"body":"Intro These are various queries to populate the collections in SCCM, which will be updated in the future.\nAdditionally, at the bottom, I have included a script for the automatic addition of the collections shown in this post\nCollections Collection Boundary Groups Based This query adds the devices that are part of a specific Boundary Group to the collection. It's necessary to modify the query by inserting the name of your own group.\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.ResourceId in (select resourceid from SMS_CollectionMemberClientBaselineStatus where SMS_CollectionMemberClientBaselineStatus.boundarygroups = \u0026#39;YOUR_BOUNDARY_GROUP_HERE\u0026#39;) and SMS_R_System.Name not in (\u0026#39;Unknown\u0026#39;) and SMS_R_System.Client = \u0026#39;1\u0026#39; Windows OS version Collections Collection Windows 10 20H2 Based This query adds devices with Windows 10 20H2 installed to the collection.\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19042\u0026#39; Collection Windows 10 21H1 Based This query adds devices with Windows 10 21H1 installed to the collection.\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19043\u0026#39; Collection Windows 10 21H2 Based This query adds devices with Windows 10 21H2 installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19044\u0026#39; Collection Windows 10 22H2 Based This query adds devices with Windows 10 22H2 installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19045\u0026#39; Collection Windows Server 2012 Based This query adds devices with Windows Server 2012 installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Server 6.2%\u0026#34; OR SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Advanced Server 6.2%\u0026#34; Collection Windows Server 2012 R2 Based This query adds devices with Windows Server 2012 R2 installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Server 6.3%\u0026#34; OR SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Advanced Server 6.3%\u0026#34; Collection Windows Server 2016 Standard Based This query adds devices with Windows Server 2016 Standard installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.14393\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2016 Standard\u0026#34; Collection Windows Server 2016 Datacenter Based This query adds devices with Windows Server 2016 Datacenter installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.14393\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2016 Datacenter\u0026#34; Collection Windows Server 2019 Standard Based This query adds devices with Windows Server 2019 Standard installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.17763\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2019 Standard\u0026#34; Collection Windows Server 2019 Datacenter Based This query adds devices with Windows Server 2019 Datacenter installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.17763\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2019 Datacenter\u0026#34; Collection Windows Server 2022 Standard Based This query adds devices with Windows Server 2022 Standard installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.20348\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2022 Standard\u0026#34; Collection Windows Server 2022 Datacenter Based This query adds devices with Windows Server 2022 Datacenter installed to the collection:\n1select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.20348\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2022 Datacenter\u0026#34; Script for Automatic Collection Creation I have created a small script for the automatic creation of collections that I use most frequently when working on a new SCCM server. This saves me a lot of time compared to manually creating each one.\nHere is the code for the script:\n1 2 # Definition of collections and their queries 3 4$collections = @( 5 @{ 6 Name = \u0026#34;Windows Server 2019 Standard Based\u0026#34; 7 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#39;10.0.17763\u0026#39; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#39;Microsoft Windows Server 2019 Standard\u0026#39;\u0026#34; 8 }, 9 @{ 10 Name = \u0026#34;Windows Server 2019 Datacenter Based\u0026#34; 11 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#39;10.0.17763\u0026#39; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#39;Microsoft Windows Server 2019 Datacenter\u0026#39;\u0026#34; 12 }, 13 @{ 14 Name = \u0026#34;Windows 10 20H2 Based\u0026#34; 15 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19042\u0026#39;\u0026#34; 16 }, 17 @{ 18 Name = \u0026#34;Windows 10 21H1 Based\u0026#34; 19 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19043\u0026#39;\u0026#34; 20 }, 21 @{ 22 Name = \u0026#34;Windows 10 21H2 Based\u0026#34; 23 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19044\u0026#39;\u0026#34; 24 }, 25 @{ 26 Name = \u0026#34;Windows 10 22H2 Based\u0026#34; 27 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.Build = \u0026#39;10.0.19045\u0026#39;\u0026#34; 28 }, 29 @{ 30 Name = \u0026#34;Windows Server 2012 Based\u0026#34; 31 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Server 6.2%\u0026#34; OR SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Advanced Server 6.2%\u0026#34;\u0026#34; 32 }, 33 @{ 34 Name = \u0026#34;Windows Server 2012 R2 Based\u0026#34; 35 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System where SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Server 6.3%\u0026#34; OR SMS_R_System.OperatingSystemNameandVersion like \u0026#34;Microsoft Windows NT Advanced Server 6.3%\u0026#34;\u0026#34; 36 }, 37 @{ 38 Name = \u0026#34;Windows Server 2016 Standard Based\u0026#34; 39 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.14393\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2016 Standard\u0026#34;\u0026#34; 40 }, 41 @{ 42 Name = \u0026#34;Windows Server 2016 Datacenter Based\u0026#34; 43 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.14393\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2016 Datacenter\u0026#34;\u0026#34; 44 }, 45 @{ 46 Name = \u0026#34;Windows Server 2019 Standard Based\u0026#34; 47 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.17763\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2019 Standard\u0026#34;\u0026#34; 48 }, 49 @{ 50 Name = \u0026#34;Windows Server 2019 Datacenter Based\u0026#34; 51 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.17763\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2019 Datacenter\u0026#34;\u0026#34; 52 }, 53 @{ 54 Name = \u0026#34;Windows Server 2022 Standard Based\u0026#34; 55 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.20348\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2022 Standard\u0026#34;\u0026#34; 56 }, 57 @{ 58 Name = \u0026#34;Windows Server 2022 Datacenter Based\u0026#34; 59 Query = \u0026#34;select SMS_R_SYSTEM.ResourceID,SMS_R_SYSTEM.ResourceType,SMS_R_SYSTEM.Name,SMS_R_SYSTEM.SMSUniqueIdentifier,SMS_R_SYSTEM.ResourceDomainORWorkgroup,SMS_R_SYSTEM.Client from SMS_R_System inner join SMS_G_System_OPERATING_SYSTEM on SMS_G_System_OPERATING_SYSTEM.ResourceID = SMS_R_System.ResourceId where SMS_G_System_OPERATING_SYSTEM.Version = \u0026#34;10.0.20348\u0026#34; and SMS_G_System_OPERATING_SYSTEM.Caption = \u0026#34;Microsoft Windows Server 2022 Datacenter\u0026#34;\u0026#34; 60 } 61 62) 63 64# Creation of collections 65foreach ($collection in $collections) { 66 $collectionName = $collection.Name 67 $collectionQuery = $collection.Query 68 69 # Create the collection 70 $newCollection = New-CMDeviceCollection -Name $collectionName -LimitingCollection \u0026#34;All Systems\u0026#34; 71 72 # Add the query rule 73 Add-CMDeviceCollectionQueryMembershipRule -CollectionId $newCollection.CollectionID -QueryExpression $collectionQuery -RuleName \u0026#34;$collectionName Rule\u0026#34; 74 75 Write-Host \u0026#34;Collection created: $collectionName\u0026#34; 76} ","link":"https://www.immiblogghenicloud.cloud/posts/sccm-collections/","section":"posts","tags":["POWERSHELL","SCCM"],"title":"SCCM collections"},{"body":"VMware Aria related links https://garyflynn.com/tags/vra/ https://vmwarecode.com/ https://blog.stijnvermoesen.be/ https://samperrin.com/ https://automateclouds.com/ https://www.brockpeterson.com/ https://blog.stijnvermoesen.be/ https://rudimartinsen.com/ https://cloudblogger.co.in/ https://kuklis.github.io/cma/ https://adrian.heissler.at/blog/ https://www.vvork.info/ https://docs.vmware.com/en/vRealize-Automation/8.11/Using-and-Managing-Service-Broker/GUID-953BBA14-530D-4606-8A34-BEA4FB552AA5.html#GUID-953BBA14-530D-4606-8A34-BEA4FB552AA5 many...\n","link":"https://www.immiblogghenicloud.cloud/usefull-links/","section":"","tags":null,"title":"Usefull Links"},{"body":"Remote Desktop Manager is a fantastic tool for centralized management of various accesses to VMs and services. I have personally always used RDM to save the RDP and SSH connections that I most frequently used.\nThis tool, when used in conjunction with Devolutions Server (DVLS), is excellent for teams that need a centralized and common repository for access.\nRecently, I found myself in need of automating the creation of entries within the various Vaults inside DVLS to reduce the effort caused by adding them manually.\nIn this post, I will show how to create a Workflow within VRO and a subscription in VRA to automate the addition of the entry following the deployment of a VM in VRA. The type of connection in this case will be a CyberarkPSM Connection. As this is a simplified example, we will statically define the Vault in which the entry will be created.\nRDM Preparation First of all, it is necessary to create an APP Account that is part of a local admin group and that has access to the Vault where you want to create the Entry.\nTo simplify the creation with all the necessary data, we create a shared Template with the information required for the connection, such as Privileged Account, PSM Server, and Connection Component. Let's take note of the name of the RDM Vault in which we want to create the connection, as we will need it later.\nCreation of the Workflow Environment First of all, it is necessary to create the Environment that includes the RDM PowerShell module.\nThe name of the module is Devolutions.Powershell, and the version in this case is 2023.2.0.9 Note Be aware of the version compatibility between the module and the DVLS server. If you are using a server version 2023.2.XX as in this example, you will need to use the ps module version 2023.2.XX; otherwise, the script will connect in Read-Only mode. It's important to have the server and ps module versions aligned.\nWorflow The workflow consists of two Scriptable tasks. The first, \u0026quot;Get Properties,\u0026quot; retrieves the VM name and IP address from the deployment by reading the InputProperties. The second, \u0026quot;AddSessionToRDMVault,\u0026quot; connects to the server and creates the entry using the data retrieved from the first script.\nAs Variables and Input/Output, we have: The JavaScript code for the Get Properties task, which has \u0026quot;inputProperties\u0026quot; as input and \u0026quot;VMresourceName\u0026quot; and \u0026quot;vmIpAddress\u0026quot; as output, is very simple:\n1var resourceName = inputProperties.get(\u0026#34;resourceNames\u0026#34;); 2var resourceIp = inputProperties.get(\u0026#39;addresses\u0026#39;)[0][0]; 3 4System.log(\u0026#34;VM Name: \u0026#34; + resourceName[0]); 5System.log(\u0026#34;VM IP: \u0026#34; + resourceIp); 6 7VMresourceName = resourceName[0]; 8vmIpAddress = resourceIp; This is the PowerShell code for the \u0026quot;AddSessionToRDMVault\u0026quot; task, which has \u0026quot;VMresourceName\u0026quot; and \u0026quot;vmIpAddress\u0026quot; as inputs.\n1function Handler($context, $inputs) { 2 3 #setup connection to dvls 4 $dsname = \u0026#34;YOUR_DVLS_SERVER_CONNECTION_NAME_HERE\u0026#34; 5 $dsurl = \u0026#34;YOUR_DVLS_SERVER_URL_HERE\u0026#34; 6 $appkey = \u0026#34;eYOUR_APP_KEY_HERE\u0026#34; 7 $appsecret = \u0026#34;YOUR_APP_SECRET_HERE\u0026#34; 8 New-RDMDataSource -DVLS -Name $dsname -Server $dsurl -ScriptingTenantID $appkey -ScriptingApplicationPassword $appsecret -SetDatasource 9 $ds = Get-RDMDataSource -Name $dsname 10 Set-RDMDatasourceProperty -DataSource $ds -Property \u0026#34;Timeout\u0026#34; -Value 60 11 Set-RDMCurrentDataSource $ds.id 12 13 #get and set vault id 14 $repo = Get-RDMRepository -Name \u0026#34;YOUR_VAULT_NAME_HERE\u0026#34; 15 $repoid = $repo.id 16 Set-RDMCurrentRepository -id $repoid 17 18 #set session input details 19 $template = Get-RDMTemplate | Where-Object -FilterScript {$_.Name -eq \u0026#34;YOUR_TEMPLATE_NAME_HERE\u0026#34;} 20 $namesess = $inputs.VMresourceName 21 $hostip = $inputs.vmIpAddress 22 23 #create Session Entry 24 $session = New-RDMSession -Name $namesess -Host $hostip -Type \u0026#34;CyberArkPSM\u0026#34; -TemplateID $template.id -SetSession 25 Set-RDMSession -Session $session -Refresh 26 Update-RDMUI 27 28 #disconnect from DVLS 29 Get-RDMDataSource | Remove-RDMDataSource 30 31 return $output 32 33} Our Workflow looks like this: Extensibility Subscription To automatically execute the workflow with every VM deployment, we need to create a Subscription within the Extensibility menu of the Cloud Assembly as follows: The event topic should be \u0026quot;Compute post provision\u0026quot; so that our workflow is initiated only after the allocation of resources is complete. In this way, all the data necessary for its execution will be available. With these settings, the Subscription will be active for any deployment of any project within the organization.It is possible to filter it by event topic or by project. See Create an extensibility subscription\nConclusions When a new VM deployment is executed, this output is obtained: In the log, many warnings of \u0026quot;The operation has timed out.\u0026quot; are visible. To solve this problem, on the suggestion of Devolutions support, I added the following line to the script:\n1Set-RDMDatasourceProperty -DataSource $ds -Property \u0026#34;Timeout\u0026#34; -Value 60 However, this did not resolve the issue with the warnings. Nonetheless, despite the warnings, the script functions correctly, and we find our entry within RDM. Unfortunately, I couldn't find useful documentation regarding the Devolutions PowerShell module, and since I don't have much time and it works, for now, I'm simply ignoring the warning.\nThe steps described in this post are simplified and may require further customization.\n","link":"https://www.immiblogghenicloud.cloud/posts/add-a-connection-entry-to-rdm-vault-on-new-vm-deployment/","section":"posts","tags":["POWERSHELL","VMWARE","RDM","VRA","VRO"],"title":"Add a connection entry to RDM Vault on new vm deployment"},{"body":"","link":"https://www.immiblogghenicloud.cloud/tags/rdm/","section":"tags","tags":null,"title":"RDM"},{"body":"Hello and welcome to I MI' BLOGGHE NI CLOUD!\nI'm Federico, an Italian guy who passionately works in the IT world, and this is my blog. Here, I plan to write some notes that I will use as a personal memory for the future.\nI thank all those who before me have shared their experience online for free, and for this reason, it seemed right to start posting some of my notes, hoping that one day they might be useful.\n","link":"https://www.immiblogghenicloud.cloud/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://www.immiblogghenicloud.cloud/series/","section":"series","tags":null,"title":"Series"}]